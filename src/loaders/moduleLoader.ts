import { stringifyRequest } from 'loader-utils'
import { selfModuleName } from '../lib/selfContext'
import {
  addLoadersAfter,
  escapeRegExpChar,
  fixResolvedCssLoaderOptions,
  getQueryObject,
  isFromModule,
  themeRequestToken,
} from '../lib/utils'
import { ValidPluginOptions } from '../options'
import { LoaderContext, PluginLoader } from '../ThemePlugin'
import varsLoader from './varsLoader'
import scopeLoader from './scopeLoader'

interface LoaderOptions extends ValidPluginOptions {
  syntax: string
}

// 添加新的loader
function injectLoader(loaderContext: LoaderContext, index: number, options: LoaderOptions) {
  const { onlyColor, syntax, extract, themeAttrName } = options
  const { ident } = loaderContext.loaders[index]
  const injected = []
  const loaderOptions = {
    token: themeRequestToken,
    isStyleModule: true,
    onlyColor,
    syntax,
  }
  if (!extract) {
    injected.push({
      path: scopeLoader.filepath,
      options: { ...loaderOptions, themeAttrName },
      ident: 'theme-scope-loader',
    })
  }
  injected.push({
    path: varsLoader.filepath,
    options: { ...loaderOptions },
    ident: 'theme-vars-loader',
  })
  addLoadersAfter(loaderContext, ident || index, injected)
}

//
function checkAndSetLoader(loaderContext: LoaderContext, options: LoaderOptions) {
  const { loaders } = loaderContext
  let { syntax } = options
  const matchLoaderRegx = new RegExp(
    String.raw`^(?:postcss|${
      syntax === 'auto' ? 'less|s[ac]ss|css' : escapeRegExpChar(syntax || 'css')
    })-loader$`
  )

  let preProcessorLoaderIndex = loaders.length
  while (--preProcessorLoaderIndex > -1) {
    if (isFromModule(matchLoaderRegx, loaders[preProcessorLoaderIndex].path)) {
      break
    }
  }

  if (preProcessorLoaderIndex !== -1) {
    if (syntax === 'auto') {
      for (const loader of loaders) {
        const loaderPath = loader.path
        if (isFromModule('sass-loader', loaderPath)) {
          syntax = 'scss'
          break
        }
        if (isFromModule('less-loader', loaderPath)) {
          syntax = 'less'
          break
        }
      }
    }

    options.syntax = syntax === 'auto' ? 'css' : syntax || 'css'
    injectLoader(loaderContext, preProcessorLoaderIndex, options)
    fixResolvedCssLoaderOptions(loaders)
  }
}

export const pitch: PluginLoader['pitch'] = function (request: string) {
  const pluginOptions = moduleLoader.getPluginOptions!()
  const { loaders } = this
  if (loaders.length < 2) {
    const { esModule } = pluginOptions

    const resource = stringifyRequest(this, `${__filename}${loaders[0].query || ''}!${request}`)
    const codeSnippets = esModule
      ? [`export * from ${resource}`, `export { default } from ${resource}`]
      : [`module.exports = require(${resource})`]

    this.callback(null, `// generated by ${selfModuleName}\n\n${codeSnippets.join('\n')}\n`)
  } else {
    const options = Object.assign(pluginOptions, getQueryObject(this.query) as { syntax: string })
    checkAndSetLoader(this, options as LoaderOptions)
    this.callback(null)
  }
}

const moduleLoader: PluginLoader = function (source, map, meta) {
  this.callback(null, source, map, meta)
}

moduleLoader.pitch = pitch
moduleLoader.filepath = __filename
export default moduleLoader
