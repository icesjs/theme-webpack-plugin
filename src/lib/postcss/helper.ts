import * as path from 'path'
import valueParser from 'postcss-value-parser'
import { Comment, Declaration, Helpers, Message, Node, Rule } from 'postcss'
import { isColorProperty } from '../colors'
import { selfModuleName } from '../selfContext'
import {
  determineCanExtractToRootDeclByIdent,
  fixScssCustomizePropertyBug,
  isTopRootDecl,
  makeVariableIdent,
  pluginName,
  RefVars,
  ThemePropertyMatcher,
  ThemeVarsMessage,
  VarsDict,
} from './tools'

type DeclValueProcessor = (
  value: string,
  isRootDecl: boolean,
  processor: DeclValueProcessor
) => string

type VariablesContainer = NonNullable<{
  context: VarsDict
  variables: VarsDict
  references: Map<string, RefVars>
}>

// 设置变量消息
export function setVarsMessage(options: {
  originalName: string
  originalValue: string
  value: string
  helper: Helpers
  dependencies?: Set<string>
  type?: ThemeVarsMessage['type']
}) {
  const { originalName, originalValue, value, helper, dependencies, type = 'theme-vars' } = options
  const messages = helper.result.messages as ThemeVarsMessage[]
  const ident = makeVariableIdent(originalName)
  const msg = {
    ident,
    type,
    value,
    plugin: pluginName,
    originalName,
    originalValue,
    dependencies,
  } as ThemeVarsMessage
  const index = messages.findIndex(
    (msg) => msg.ident === ident && msg.type === type && msg.plugin === pluginName
  )
  if (index !== -1) {
    messages.splice(index, 1, msg)
  } else {
    messages.push(msg)
  }
  return msg
}

// 获取变量数据
export function getVarsMessages(
  messages: Message[],
  type: ThemeVarsMessage['type'] | ((msg: ThemeVarsMessage) => boolean) = 'theme-vars'
) {
  return messages.filter((msg) => {
    if (msg.plugin !== pluginName) {
      return false
    }
    if (typeof type === 'string') {
      return msg.type === type
    }
    if (typeof type === 'function') {
      return type(msg as ThemeVarsMessage)
    }
    return false
  }) as ThemeVarsMessage[]
}

// 获取变量抽取迭代处理函数。
// 消息 theme-vars。
export function getDeclProcessor(
  onlyColor: boolean,
  syntax: string,
  vars: VariablesContainer,
  regExps: ThemePropertyMatcher,
  helper: Helpers
) {
  // 值处理器
  const processor: DeclValueProcessor = getDeclValueProcessor(onlyColor, vars, regExps, helper)

  // 返回属性声明处理函数
  return (decl: Declaration) => {
    if (onlyColor && !regExps[2].test(decl.prop) && !isColorProperty(decl.prop)) {
      return
    }
    decl.value = processor(decl.value, isTopRootDecl(decl), processor)
    if (regExps[2].test(decl.prop)) {
      decl.value = fixScssCustomizePropertyBug(decl.value, syntax, regExps)
    }
  }
}

// 创建自定义属性声明
export function createVarsRootRuleNode(options: {
  properties: VarsDict
  syntax: string
  regExps: ThemePropertyMatcher
  helper: Helpers
  asComment?: boolean
}) {
  const { properties, syntax, regExps, helper, asComment } = options
  const root = helper.result.root
  const decls = []
  const values = new Set<string>()
  for (const [ident, { originalValue, value }] of properties) {
    values.add(originalValue)
    decls.push(
      helper.decl({
        prop: ident,
        value: originalValue,
        raws: { between: ':', value: { value: originalValue, raw: value } },
      })
    )
  }
  let node: Rule | Comment = helper.rule({
    selector: ':root',
    nodes: decls,
  })
  let prevNode
  for (const node of root.nodes) {
    if (node.type === 'atrule' && node.name === 'import') {
      // @import 规则
      prevNode = node
    } else if (node.type === 'decl' && regExps[1].test(node.prop) && values.has(node.prop)) {
      // 引用了该变量
      prevNode = node
    }
  }
  if (asComment) {
    node = toComment(node, helper)
  } else {
    // 写入 :root 节点，需要合并至已有的 :root 节点上
    // 不然 eslint 检查通不过
    node = mergeTopRootDecls(node.nodes as Declaration[], regExps, syntax, helper)
  }
  if (prevNode) {
    root.insertAfter(prevNode, node)
  } else {
    root.prepend(node)
  }
  return node
}

// 添加标题注释
export function addTitleComment(node: Rule | Comment, helper: Helpers) {
  const root = helper.result.root
  const file = root.source?.input.file || ''
  const divider = '=========================================================================='
  const waterMark = `Generated by ${selfModuleName} <star2018@outlook.com>`.padEnd(divider.length)
  root.insertBefore(
    node,
    helper.comment({
      text: `Theme Variables ${
        file ? `(${path.relative(process.cwd(), file)})` : ''
      }\n * ${divider} *\n * ${waterMark} *\n * ${divider}`,
      raws: { before: '\n\n', left: '*\n * ', right: ' ' },
    })
  )
  //
}

// 转换节点为注释
function toComment(node: Node, helper: Helpers) {
  return helper.comment({
    text: node
      .toString(helper.stringify)
      .split('\n')
      .map(
        (line) =>
          ` * ${line.replace(
            /^(\s+)(.*)/,
            // 4空格缩进格式转换为2空格缩进
            (t, g1, g2) => ''.padEnd(2 * Math.floor(g1.length / 4) + (g1 % 4)) + g2
          )}`
      )
      .join('\n'),
    raws: { before: '\n', left: '*\n *\n', right: '\n *\n ' },
  })
}

// 获取属性声明的值处理函数
function getDeclValueProcessor(
  onlyColor: boolean,
  vars: VariablesContainer,
  regExps: ThemePropertyMatcher,
  helper: Helpers
) {
  const { context, variables, references } = vars
  return (value: string, isRootDecl: boolean, processor: DeclValueProcessor) => {
    if (!value) {
      return ''
    }

    let changed = false
    const parsed = valueParser(value)

    // 迭代值节点
    parsed.walk((node) => {
      if (node.type === 'word' && regExps[isRootDecl ? 0 : 1].test(node.value)) {
        const varName = node.value
        const ident = makeVariableIdent(varName)
        const refVars = references.get(ident)
        if (refVars) {
          changed = true
          // 递归处理引用值
          node.value = processor(refVars.originalValue, isRootDecl, processor)
          //
        } else if (determineCanExtractToRootDeclByIdent(ident, onlyColor, context, variables)) {
          //
          const originalValue = node.value
          const value = variables.get(ident)?.value
          setVarsMessage({
            originalName: varName,
            originalValue,
            value: value || originalValue,
            helper,
            type: 'theme-vars',
          })
          changed = true
          node.value = `var(${ident}, ${originalValue})`
        }
      }
    })

    // 修改声明值
    return changed ? valueParser.stringify(parsed.nodes) : value
  }
}

// 合并属性声明到:root中去
function mergeTopRootDecls(
  decls: Declaration[],
  regExps: ThemePropertyMatcher,
  syntax: string,
  helper: Helpers
) {
  const rootRule = helper.rule({
    selector: ':root',
    nodes: decls,
  })
  // 合并:root节点
  for (const node of helper.result.root.nodes) {
    if (node.type === 'rule' && node.selector === ':root') {
      for (const decl of node.nodes) {
        rootRule.append(decl.clone())
      }
      node.remove()
    }
  }
  // 修复scss的bug
  rootRule.walkDecls(regExps[2], (decl) => {
    decl.value = fixScssCustomizePropertyBug(decl.value, syntax, regExps)
  })
  return rootRule
}
