import * as path from 'path'
import valueParser from 'postcss-value-parser'
import { Comment, Declaration, Helpers, Message, Node, Rule } from 'postcss'
import { isColorProperty } from '../colors'
import { selfModuleName } from '../selfContext'
import { isRelativePath, normalizeRelativePath } from '../utils'
import {
  determineCanExtractToRootDeclByIdent,
  fixScssCustomizePropertyBug,
  isTopRootDecl,
  makeVariableIdent,
  pluginName,
  RefVars,
  ThemePropertyMatcher,
  ThemeVarsMessage,
  URLVarsDict,
  VarsDict,
} from './tools'

type DeclValueProcessor = (
  value: string,
  isRootDecl: boolean,
  processor: DeclValueProcessor
) => string

type VariablesContainer = NonNullable<{
  context: VarsDict
  variables: VarsDict
  urlVars: URLVarsDict
  references: Map<string, RefVars>
}>

type PropertyLike = {
  ident: string
  value: string
  originalValue: string
}

interface VarsMessageOptions extends Omit<ThemeVarsMessage, 'ident' | 'type' | 'plugin'> {
  helper: Helpers
  ident?: string
  type?: ThemeVarsMessage['type']
}

type CreateRuleOptions = {
  properties: VarsDict
  urlVars: URLVarsDict
  syntax: string
  regExps: ThemePropertyMatcher
  helper: Helpers
  asComment?: boolean
}

// 设置变量消息
export function setVarsMessage(options: VarsMessageOptions) {
  const {
    originalName,
    type = 'theme-vars',
    ident = makeVariableIdent(originalName),
    helper,
    ...rest
  } = options
  const msg = { ...rest, originalName, type, ident, plugin: pluginName } as ThemeVarsMessage
  delete (msg as any).decl
  const messages = helper.result.messages as ThemeVarsMessage[]
  const index = messages.findIndex(
    (msg) => msg.ident === ident && msg.type === type && msg.plugin === pluginName
  )
  if (index !== -1) {
    messages.splice(index, 1, msg)
  } else {
    messages.push(msg)
  }
  return msg
}

// 获取变量数据
export function getVarsMessages(
  messages: Message[],
  type: ThemeVarsMessage['type'] | ((msg: ThemeVarsMessage) => boolean) = 'theme-vars'
) {
  return messages.filter((msg) => {
    if (msg.plugin !== pluginName) {
      return false
    }
    if (typeof type === 'string') {
      return msg.type === type
    }
    if (typeof type === 'function') {
      return type(msg as ThemeVarsMessage)
    }
    return false
  }) as ThemeVarsMessage[]
}

// 获取变量抽取迭代处理函数。
// 消息 theme-vars。
export function getDeclProcessor(
  onlyColor: boolean,
  syntax: string,
  vars: VariablesContainer,
  regExps: ThemePropertyMatcher,
  helper: Helpers
) {
  // 值处理器
  const processor: DeclValueProcessor = getDeclValueProcessor(onlyColor, vars, regExps, helper)

  // 返回属性声明处理函数
  return (decl: Declaration) => {
    if (onlyColor && !regExps[2].test(decl.prop) && !isColorProperty(decl.prop)) {
      return
    }
    decl.value = processor(decl.value, isTopRootDecl(decl), processor)
    if (regExps[2].test(decl.prop)) {
      decl.value = fixScssCustomizePropertyBug(decl.value, syntax, regExps)
    }
  }
}

// 添加标题注释
export function addTitleComment(node: Rule | Comment, helper: Helpers) {
  const root = helper.result.root
  const file = root.source?.input.file || ''
  const divider = '=========================================================================='
  const waterMark = `Generated by ${selfModuleName} <star2018@outlook.com>`.padEnd(divider.length)
  root.insertBefore(
    node,
    helper.comment({
      text: `Theme Variables ${
        file ? `(${path.relative(process.cwd(), file)})` : ''
      }\n * ${divider} *\n * ${waterMark} *\n * ${divider}`,
      raws: { before: '\n\n', left: '*\n * ', right: ' ' },
    })
  )
  //
}

// 创建自定义属性声明
export function createVarsRootRuleNode(options: CreateRuleOptions) {
  const { syntax, regExps, helper, asComment } = options
  const { decls, values } = createDeclarations(options)
  const root = helper.result.root

  let node: Rule | Comment = createRootRule(decls, syntax, helper)
  let prevNode
  for (const node of root.nodes) {
    if (node.type === 'atrule' && node.name === 'import') {
      // @import 规则
      prevNode = node
    } else if (node.type === 'decl' && regExps[1].test(node.prop) && values.has(node.prop)) {
      // 引用了该变量
      prevNode = node
    }
  }
  if (asComment) {
    node = toComment(node, helper)
  } else {
    // 写入 :root 节点，需要合并至已有的 :root 节点上
    // 不然 eslint 检查通不过
    node = mergeTopRootDecls(node.nodes as Declaration[], regExps, syntax, helper)
  }
  if (prevNode) {
    root.insertAfter(prevNode, node)
  } else {
    root.prepend(node)
  }
  return node
}

// 创建:root规则对象
function createRootRule(decls: Declaration[], syntax: string, helper: Helpers) {
  return helper.rule({
    selector: ':root',
    nodes: decls,
    raws: {
      // 最后一条声明语句要以";"结尾，不然less等解析器会报错
      semicolon: /css|less|scss/.test(syntax),
    },
  })
}

// 创建属性声明对象
function createDeclarations(options: CreateRuleOptions) {
  const { properties, urlVars, helper, asComment } = options
  const decls = []
  const values = new Set<string>()
  for (const property of properties.values()) {
    // 这里调用顺序很重要，要先更新再取值
    // 更新：
    const updated = updateURLProperty(property, urlVars, helper)
    // 取值：
    const { ident, originalValue, value } = property
    const declValue = updated ? value : originalValue

    values.add(originalValue)
    decls.push(
      helper.decl({
        prop: ident,
        value: declValue,
        raws: {
          between: `: `,
          value: {
            value: declValue,
            raw: asComment ? value : declValue,
          },
        },
      })
    )
  }

  return { decls, values }
}

// 合并属性声明到:root中去
function mergeTopRootDecls(
  decls: Declaration[],
  regExps: ThemePropertyMatcher,
  syntax: string,
  helper: Helpers
) {
  const rootRule = createRootRule(decls, syntax, helper)
  // 合并:root节点
  for (const node of helper.result.root.nodes) {
    if (node.type === 'rule' && node.selector === ':root') {
      for (const decl of node.nodes) {
        rootRule.append(decl.clone())
      }
      node.remove()
    }
  }
  // 修复scss的bug
  rootRule.walkDecls(regExps[2], (decl) => {
    decl.value = fixScssCustomizePropertyBug(decl.value, syntax, regExps)
  })
  return rootRule
}

// 转换节点为注释
function toComment(node: Node, helper: Helpers) {
  return helper.comment({
    text: node
      .toString(helper.stringify)
      .split('\n')
      .map(
        (line) =>
          ` * ${line.replace(
            /^(\s+)(.*)/,
            // 4空格缩进格式转换为2空格缩进
            (t, g1, g2) => ''.padEnd(2 * Math.floor(g1.length / 4) + (g1 % 4)) + g2
          )}`
      )
      .join('\n'),
    raws: { before: '\n', left: '*\n *\n', right: '\n *\n ' },
  })
}

// 修正属性声明中的外部资源引用地址
// 影响写入样式文件中的属性值
function updateURLProperty(property: PropertyLike, urlVars: URLVarsDict, helper: Helpers) {
  const { ident, value } = property
  const { result } = helper
  const sourceFile = result.root.source?.input.file || result.opts.from
  if (!sourceFile || !urlVars.has(ident)) {
    return
  }
  const { data, from } = urlVars.get(ident)!
  const relativeUrls = new Set([...data].filter((url) => isRelativePath(url)))
  if (!relativeUrls.size) {
    return
  }

  const context = path.dirname(sourceFile)
  const fromContext = path.dirname(from)
  const parsed = valueParser(value)
  let updated = false

  parsed.walk((node) => {
    if (node.type === 'function') {
      valueParser.walk(node.nodes, (child) => {
        const url = child.value
        if (relativeUrls.has(url)) {
          // 转换路径到当前文件上下文
          const rewrittenUrl = normalizeRelativePath(
            path.relative(context, path.join(fromContext, url))
          )
          if (rewrittenUrl !== normalizeRelativePath(url)) {
            updated = true
            child.value = rewrittenUrl
          }
        }
      })
      return false
    }
  })

  if (updated) {
    property.value = valueParser.stringify(parsed.nodes)
  }
  return updated
}

// 获取属性声明的值处理函数
// 修改被处理样式文件的主要方法
function getDeclValueProcessor(
  onlyColor: boolean,
  vars: VariablesContainer,
  regExps: ThemePropertyMatcher,
  helper: Helpers
) {
  const { context, variables, references, urlVars } = vars
  return (value: string, isRootDecl: boolean, processor: DeclValueProcessor) => {
    if (!value) {
      return ''
    }

    let changed = false
    const parsed = valueParser(value)

    // 迭代值节点
    parsed.walk((node) => {
      if (node.type === 'word' && regExps[isRootDecl ? 0 : 1].test(node.value)) {
        const varName = node.value
        const ident = makeVariableIdent(varName)
        const refVars = references.get(ident)
        if (refVars) {
          changed = true
          // 递归处理引用值
          node.value = processor(refVars.originalValue, isRootDecl, processor)
          //
        } else if (determineCanExtractToRootDeclByIdent(ident, onlyColor, context, variables)) {
          //
          const originalValue = node.value
          const value = variables.get(ident)?.value || originalValue
          setVarsMessage({
            ident,
            originalName: varName,
            originalValue,
            isRootDecl,
            value,
            helper,
            type: 'theme-vars',
          })

          // 检查相对URL地址引用，并更新属性值
          const property = { ident, value, originalValue }
          const updated = updateURLProperty(property, urlVars, helper)

          // 如果存在外部资源URL引用地址修正，则使用解析后的值，否则，使用原始的值
          const defaultValue = updated ? property.value : property.originalValue
          node.value = `var(${ident}, ${defaultValue})`
          changed = true
        }
      }
    })

    // 修改声明值
    return changed ? valueParser.stringify(parsed.nodes) : value
  }
}
